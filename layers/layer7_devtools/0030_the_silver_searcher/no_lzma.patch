diff -up the_silver_searcher-2.2.0/src/zfile.c.orig the_silver_searcher-2.2.0/src/zfile.c
--- the_silver_searcher-2.2.0/src/zfile.c.orig	2018-08-07 08:43:51.000000000 +0200
+++ the_silver_searcher-2.2.0/src/zfile.c	2019-12-26 16:28:01.368416646 +0100
@@ -61,7 +61,9 @@ struct zfile {
 
     union {
         z_stream gz;
+#ifdef HAVE_LZMA_H
         lzma_stream lzma;
+#endif
     } stream;
 
     uint8_t inbuf[32 * KB];
@@ -69,9 +71,13 @@ struct zfile {
     bool eof;
 };
 
+#ifdef HAVE_LZMA_H
 #define CAVAIL_IN(c) ((c)->ctype == AG_GZIP ? (c)->stream.gz.avail_in : (c)->stream.lzma.avail_in)
 #define CNEXT_OUT(c) ((c)->ctype == AG_GZIP ? (c)->stream.gz.next_out : (c)->stream.lzma.next_out)
-
+#else
+#define CAVAIL_IN(c) (c)->stream.gz.avail_in
+#define CNEXT_OUT(c) (c)->stream.gz.next_out
+#endif
 static int
 zfile_cookie_init(struct zfile *cookie) {
 #ifdef HAVE_LZMA_H
@@ -207,7 +213,9 @@ zfile_read(void *cookie_, char *buf, siz
     struct zfile *cookie = cookie_;
     size_t nb, ignorebytes;
     ssize_t total = 0;
+#ifdef HAVE_LZMA_H
     lzma_ret lzret;
+#endif
     int ret;
 
     assert(size <= SSIZE_MAX);
@@ -219,7 +227,9 @@ zfile_read(void *cookie_, char *buf, siz
         return 0;
 
     ret = Z_OK;
+#ifdef HAVE_LZMA_H
     lzret = LZMA_OK;
+#endif
 
     ignorebytes = cookie->logic_offset - cookie->decode_offset;
     assert(ignorebytes == 0);
@@ -272,8 +282,12 @@ zfile_read(void *cookie_, char *buf, siz
         assert(cookie->stream.gz.next_out ==
                &cookie->outbuf[cookie->outbuf_start]);
 
+#ifdef HAVE_LZMA_H
         if ((cookie->ctype == AG_XZ && lzret == LZMA_STREAM_END) ||
             (cookie->ctype == AG_GZIP && ret == Z_STREAM_END)) {
+#else
+        if ((cookie->ctype == AG_GZIP && ret == Z_STREAM_END)) {
+#endif
             cookie->eof = true;
             break;
         }
@@ -290,6 +304,7 @@ zfile_read(void *cookie_, char *buf, siz
                 warn("truncated file");
                 exit(1);
             }
+#ifdef HAVE_LZMA_H
             if (cookie->ctype == AG_XZ) {
                 cookie->stream.lzma.avail_in = nb;
                 cookie->stream.lzma.next_in = cookie->inbuf;
@@ -297,9 +312,14 @@ zfile_read(void *cookie_, char *buf, siz
                 cookie->stream.gz.avail_in = nb;
                 cookie->stream.gz.next_in = cookie->inbuf;
             }
+#else
+            cookie->stream.gz.avail_in = nb;
+            cookie->stream.gz.next_in = cookie->inbuf;
+#endif
         }
 
         /* Reset stream state to beginning of output buffer */
+#ifdef HAVE_LZMA_H
         if (cookie->ctype == AG_XZ) {
             cookie->stream.lzma.next_out = cookie->outbuf;
             cookie->stream.lzma.avail_out = sizeof cookie->outbuf;
@@ -307,6 +327,10 @@ zfile_read(void *cookie_, char *buf, siz
             cookie->stream.gz.next_out = cookie->outbuf;
             cookie->stream.gz.avail_out = sizeof cookie->outbuf;
         }
+#else
+        cookie->stream.gz.next_out = cookie->outbuf;
+        cookie->stream.gz.avail_out = sizeof cookie->outbuf;
+#endif
         cookie->outbuf_start = 0;
 
         if (cookie->ctype == AG_GZIP) {
@@ -315,12 +339,14 @@ zfile_read(void *cookie_, char *buf, siz
                 log_err("Found mem/data error while decompressing zlib stream: %s", zError(ret));
                 return -1;
             }
+#ifdef HAVE_LZMA_H
         } else {
             lzret = lzma_code(&cookie->stream.lzma, LZMA_RUN);
             if (lzret != LZMA_OK && lzret != LZMA_STREAM_END) {
                 log_err("Found mem/data error while decompressing xz/lzma stream: %d", lzret);
                 return -1;
             }
+#endif
         }
         inflated = CNEXT_OUT(cookie) - &cookie->outbuf[0];
         cookie->actual_len += inflated;
